# Hometask 1-2

## Task 0
Настроить внутренную сеть между двумя ВМ.

**1. Настройка сетевого адаптера**

На ВМ1 и на ВМ2 добавляем по сетевому адаптеру с типом подключения ***Внутрення сеть*** (или ***Internal Network***). На ВМ2, у которой не должно быть больше подключений, кроме как с ВМ1, этот адаптер должен быть единственным!

![Пример вывода команды](/1-2/screenshots/task0_1.png)
![Пример вывода команды](/1-2/screenshots/task0_2.png)

**2. Настройка сетевых интерфейсов**

Обе машины должны иметь адреса из одной подсети. Выделим для них подсеть 10.0.3.0/24.

IP-адрес ВМ1: 10.0.3.5

IP-адрес ВМ2: 10.0.3.6

Указанные IP-адреса зададим статически.
 
 * Настройка сетевого интерфейса ВМ1
 
 Нужный нам сетевой интерфейс на ВМ1:
 
 ![Пример вывода команды](/1-2/screenshots/task0_3.png)
 
 Добавим следующие строки в файл */etc/sysconfig/network-scripts/ifcfg-enp0s9*:
  ```sh
 $ sudo vi /etc/sysconfig/network-scripts/ifcfg-enp0s9
 ```
 ```sh
 BOOTPROTO=static
 NAME=enp0s9
 IPADDR="10.0.3.5"
 NETMASK="255.255.255.0"
 DEVICE=enp0s9
 ONBOOT=yes
 ```
 
 ![Пример вывода команды](/1-2/screenshots/task0_4.png)
 
 Перезагрузим настройки сети и проверим состояние сетевых интерфейсов ВМ1.
 
 ```sh
 $ sudo systemctl restart network
 $ ip a
 ```
 
 ![Пример вывода команды](/1-2/screenshots/task0_5.png)
 
 * Настройка сетевого интерфейса ВМ2
 
 Нужный нам сетевой интерфейс на ВМ2:
 
 ![Пример вывода команды](/1-2/screenshots/task0_6.png)
 
 Добавим следующие строки в файл */etc/sysconfig/network-scripts/ifcfg-enp0s3*:
 
 ```sh
 $ sudo vi /etc/sysconfig/network-scripts/ifcfg-enp0s3
 ```
 ```sh
 BOOTPROTO=static
 NAME=enp0s3
 IPADDR="10.0.3.6"
 NETMASK="255.255.255.0"
 DEVICE=enp0s3
 ONBOOT=yes
 ```
 
 ![Пример вывода команды](/1-2/screenshots/task0_7.png)
 
 Перезагрузим настройки сети и проверим состояние сетевых интерфейсов ВМ2.
 
 ```sh
 $ sudo systemctl restart network
 $ ip a
 ```
 
 ![Пример вывода команды](/1-2/screenshots/task0_8.png)

**3. Проверка доступности внешних устройств по сети**

* c хоста (ОС Win10):

```sh
#чтобы узнать ip-адрес хоста
$ ipconfig
```

 ![Пример вывода команды](/1-2/screenshots/task0_9.png)
 
*192.168.56.2* - ip-адрес, назначенный статически ВМ1 на сетевой интерфейс для виртуального адаптера Host-only (сеть между гостевой и хостов машинами).

```sh
$ ping 192.168.56.2
$ ping 10.0.3.6 
```

 ![Пример вывода команды](/1-2/screenshots/task0_10.png)

* с ВМ1 (*192.168.56.1* - ip-адрес хоста):

```sh
$ ping 10.0.3.6
$ ping 192.168.56.1 
$ ping 8.8.8.8
```

 ![Пример вывода команды](/1-2/screenshots/task0_11.png)

* с ВМ2:
```sh
$ ping 10.0.3.5
$ ping 192.168.56.1 
$ ping 8.8.8.8
```

 ![Пример вывода команды](/1-2/screenshots/task0_12.png)


***


## Task 1

1) Используя команду ls, необходимо вывести на экран все файлы, которые расположены в секционных директориях /usr/share/man/manX и содержат слово "config" в имени. 
```sh
$ ls /usr/share/man/man?/*config*
```

![Пример вывода команды](/1-2/screenshots/task1_1.png)


2) Одним вызовом ls найти все файлы, содержащие слово "system" в каталогах /usr/share/man/man1 и /usr/share/man/man7
```sh
$ ls /usr/share/man/man[1,7]/*system*
```

![Пример вывода команды](/1-2/screenshots/task1_2.png)

***


## Task 2

1) Найти в директории /usr/share/man все файлы, которые содержат слово "help" в имени, найти там же все файлы, имя которых начинается на "conf".
```sh
$ find /usr/share/man –name "*help*" –o –name "conf*"
```

![Пример вывода команды](/1-2/screenshots/task2_1.png)

2) Какие действия мы можем выполнить с файлами, найденными командой find (не запуская других команд)? 

- **-delete** – удаление найденного(-ых) файла(-ов). Например, команда ниже удалит все файлы имя, которых содержит "file" и еще 1 символ после (в директории ~/test всего 3 таких файла: "file1", "file2", "file3").
```sh
$ find ~/test –name "file?" -delete
```

![Пример вывода команды](/1-2/screenshots/task2_2.png)

- **-ls** – вывод информации о найденном(-ых) файле(-ах): 
   * идентификатор файла в файловой системе; 
   * права доступа к файлу; 
   * число возможных ссылок на файл (1 – для обычного файла, 2 и больше – для директорий); 
   * имя владельца файла;
   * имя группы, которой принадлежит владелец файла;
   * размер файла;
   * дата последнего изменения;
   * полный путь к файлу.
```sh
$ find ~/test –name "file?" -ls
```

![Пример вывода команды](/1-2/screenshots/task2_3.png)

- **-print** – вывод полного пути к найденному(-ым) файлу(-ам)

```sh
$find ~/test –name "file?" -print
```

![Пример вывода команды](/1-2/screenshots/task2_4.png)

- **-printf** -  форматированный вывод информации о файле (почти как printf в С), подробнее о флагах можно прочитать в справочной информации. Ниже пример форматированного вывода с отображением прав доступа к файлу, имени владельца файла и имя его группы, размер файла, дата последней модификации и его имя:
```sh
$ find ~/test -name "file?" -printf "%p size=%s %M %y %u %g %Tx %TH:%TM\n"
```

![Пример вывода команды](/1-2/screenshots/task2_5.png)

- есть варианты вызова трёх последних команд для вывода результата в файл (**-fls**, **-fprint** и **-fprintf** для -ls, -print и -printf соответственно)
```sh
$ find ~/test -name "file?" -fprint ~/test/paths
```
![Пример вывода команды](/1-2/screenshots/task2_7.png)

- можно еще вызывать другие утилиты через параметр **–exec** или **-ok**. Вызов операции через параметр **-ok**, то же, что и -exec, но требует подтверждения выполнения операции от пользователя для каждого найденного файла. 
```sh
$ find ~/test -regex '.*file_[1-3]' -ok mv {} {}_new \; # {} - подставляет полное имя обрабатываемого файла
```

На скриншоте представлен пример поиска файлов в папке ~/test, имя которых подходит под указанное регулярное выражение (regexp), и переименовывает найденные файлы (путем добавления постфикса "\_new" к существующемуу имени), если получено подверждение выполнения операции от пользователя (ввод *'y'*).

![Пример вывода команды](/1-2/screenshots/task2_6.png)
***


## Task 3

При помощи команд head и tail, вывести последние 2 строки файла /etc/fstab и первые 7 строк файла /etc/yum.conf
```sh
$ tail -n2 /etc/fstab
```

![Пример вывода команды](/1-2/screenshots/task3_2.png)

```sh
$ head -n7 /etc/yum.conf
```

![Пример вывода команды](/1-2/screenshots/task3_2.png)

Если запросим для отображения больше строк, чем есть в файле, то утилита отобразит файл **целиком**.
 Для демонстрации этого создадим файл *test_file* с 3-мя строками.

![Пример вывода команды](/1-2/screenshots/task3_3.png)

***

## Task 5
Написать как можно больше различных вариантов команды cd, с помощью которых вы можете вернуться в домашнюю директорию вашего пользователя из директории */mnt*. Различные относительные пути также считаются разными вариантами.
```sh
$ cd               # 1 - возврат в домашнюю директорию
$ cd -             # 2 - возврат в директорию, из которой перешли в текущую
$ cd ~             # 3 - ~ заменяет путь к домашней директорию
$ cd ~/            # 4 
$ cd $HOME         # 5 - глобальная переменная HOME хранит путь к домашней директории текущего пользователя 
$ cd $HOME/        # 6 
$ cd /home/$USER   # 7 - глобальная переменная USER хранит имя текущего пользователя
$ cd /home/$USER/  # 8 
$ cd /home/admin   # 9 - абсолютный путь к домашней директории текущего пользователя
$ cd /home/admin/  # 10

```
![Пример вывода команды](/1-2/screenshots/task5_1.png)

***

## Task 6
Создайть одной командой в домашней директории 3 папки new, in-process, processed. При этом in-process должна содержать в себе еще 3 папки tread0, tread1, tread2.
```sh
$ mkdir new in-process{,/thread{0..2}} processed
```

![Пример вывода команды](/1-2/screenshots/task6_1.png)

Далее создать 100 файлов формата data[[:digit:]][[:digit:]] в папке new. 
```sh
$ touch ./new/data{0..9}{0..9}
```

![Пример вывода команды](/1-2/screenshots/task6_2.png)

Скопировать 34 файла в tread0 и по 33 в tread1 и tread2 соответственно. Вывести содержимое каталога in-process одной командой.
```sh
$ cp ./new/data{00..33} ./in-process/thread0/
$ cp ./new/data{34..66} ./in-process/thread1/
$ cp ./new/data{67..99} ./in-process/thread2/

$ ls ./in-process/thread{0..2}
```

![Пример вывода команды](/1-2/screenshots/task6_3.png)

После этого переместить все файлы из каталогов tread в processed одной командой. 
```sh
$ mv ./in-process/thread{0..2}/data[[:digit:]][[:digit:]] ./processed/
```

![Пример вывода команды](/1-2/screenshots/task6_4.png)

Вывести содержимое каталога in-process и processed опять же одной командой.
```sh
$ ls ./in-process/thread{0..2} ./processed
```

![Пример вывода команды](/1-2/screenshots/task6_5.png)

Сравнить количество файлов в каталогах new и processed при помощи изученных ранее команд, если они равны удалите файлы из new.
```sh
# [ 'str1' = 'str2' ] && < выполнится, если str1 == str2 > || < выполнится, если str1 != str2 > 

$ [ $(ls ./new | wc -l) = $(ls ./processed | wcw -l) ] && rm ./new/data[[:digit:]][[:digit:]] || echo "Numbers of files are not equal." 
```

![Пример вывода команды](/1-2/screenshots/task6_6.png)

***

## Task 7
Согласно [документации *bash*](https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html#:~:text=The%20order%20of%20expansions%20is,additional%20expansion%20available%3A%20process%20substitution%20.) ***brace expansion*** выполняется в первую очередь, в том числе до подстановки значений переменных в команду *(parameter and variable expansion)* и до подстановки команд *(command substitution)*.

Таким образом, выполнение следующей команды:
```sh
$ a=1; b=3
$ echo file{$a..$b}
```
Приведёт к следующему результату:

![Пример вывода команды](/1-2/screenshots/task7_1.png)

Для того, чтобы добиться желаемого результата, воспользуемся командой *eval*, которая позволяет сначала подставить значения всех переменных в строку, формирует итоговую строку, а затем выполняет её. 

В нашем примере достаточно изменить лишь последнюю строчку: 
```sh
$ a=1; b=3
$ eval echo file{$a..$b}  # то есть выполнится 'echo file{1..3}'
```
![Пример вывода команды](/1-2/screenshots/task7_2.png)


Отдельно промментирую, что попытка использовать конструкцию подстановки команды *$()* не сработает, ведь, как уже было сказано выше, *brace expansion* "{\<start\>..\<end\>}" обрабатывается **до** конструкции подстановки команд *$()*. 
  
```sh
# bash не увидит brace expansion вида {<s>..<e>} ВО ВСЕМ выражении 
# и выполнит 'echo "file{1..3}"', что передаст внешнем echo строку 'file{1..3}'

$ echo $(echo file{$a..$b}) 
```

![Пример вывода команды](/1-2/screenshots/task7_3.png)
