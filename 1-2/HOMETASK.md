# Hometask 1-2

## Task 1
1) Используя команду ls, необходимо вывести на экран все файлы, которые расположены в секционных директориях /usr/share/man/manX и содержат слово "config" в имени. 
```sh
$ ls /usr/share/man/man?/*config*
```
![Пример вывода команды](/1-2/screenshots/task1_1.png)


2) Одним вызовом ls найти все файлы, содержащие слово "system" в каталогах /usr/share/man/man1 и /usr/share/man/man7
```sh
$ ls /usr/share/man/man[1,7]/*system*
```
![Пример вывода команды](/1-2/screenshots/task1_2.png)

***


## Task 2
1) Найти в директории /usr/share/man все файлы, которые содержат слово "help" в имени, найти там же все файлы, имя которых начинается на "conf".
```sh
$ find /usr/share/man –name "*help*" –o –name "conf*"
```

![Пример вывода команды](/1-2/screenshots/task2_1.png)

2) Какие действия мы можем выполнить с файлами, найденными командой find (не запуская других команд)? 
- **-delete** 
– удаление найденного(-ых) файла(-ов). Например, команда ниже удалит все файлы имя, которых содержит "file" и еще 1 символ после (в директории ~/test всего 3 таких файла: "file1", "file2", "file3").
```sh
$ find ~/test –name "file?" -delete
```

![Пример вывода команды](/1-2/screenshots/task2_2.png)

- **-ls** – вывод информации о найденном(-ых) файле(-ах): 
   * идентификатор файла в файловой системе; 
   * права доступа к файлу; 
   * число возможных ссылок на файл (1 – для обычного файла, 2 и больше – для директорий); 
   * имя владельца файла;
   * имя группы, которой принадлежит владелец файла;
   * размер файла;
   * дата последнего изменения;
   * полный путь к файлу.
```sh
$ find ~/test –name "file?" -ls
```

![Пример вывода команды](/1-2/screenshots/task2_3.png)

- **-print** – вывод полного пути к найденному(-ым) файлу(-ам)
```sh
$find ~/test –name "file?" -print
```

![Пример вывода команды](/1-2/screenshots/task2_4.png)

- **-printf** -  форматированный вывод информации о файле (почти как printf в С), подробнее о флагах можно прочитать в справочной информации. Ниже пример форматированного вывода с отображением прав доступа к файлу, имени владельца файла и имя его группы, размер файла, дата последней модификации и его имя:
```sh
$ find ~/test -name "file?" -printf "%p size=%s %M %y %u %g %Tx %TH:%TM\n"
```

![Пример вывода команды](/1-2/screenshots/task2_5.png)

- есть варианты вызова трёх последних команд для вывода результата в файл (**-fls**, **-fprint** и **-fprintf** для -ls, -print и -printf соответственно)
```sh
$ find ~/test -name "file?" -fprint ~/test/paths
```
![Пример вывода команды](/1-2/screenshots/task2_7.png)

- можно еще вызывать другие утилиты через параметр **–exec** или **-ok**. Вызов операции через параметр **-ok**, то же, что и -exec, но требует подтверждения выполнения операции от пользователя для каждого найденного файла. 
```sh
$ find ~/test -regex '.*file_[1-3]' -ok mv {} {}_new \; # {} - подставляет полное имя обрабатываемого файла
```

На скриншоте представлен пример поиска файлов в папке ~/test, имя которых подходит под указанное регулярное выражение (regexp), и переименовывает найденные файлы (путем добавления постфикса "\_new" к существующемуу имени), если получено подверждение выполнения операции от пользователя (ввод *'y'*).

![Пример вывода команды](/1-2/screenshots/task2_6.png)
***


## Task 3
При помощи команд head и tail, вывести последние 2 строки файла /etc/fstab и первые 7 строк файла /etc/yum.conf
```sh
$ tail -n2 /etc/fstab
```

![Пример вывода команды](/1-2/screenshots/task3_2.png)

```sh
$ head -n7 /etc/yum.conf
```

![Пример вывода команды](/1-2/screenshots/task3_2.png)

Если запросим для отображения больше строк, чем есть в файле, то утилита отобразит файл **целиком**.
 Для демонстрации этого создадим файл *test_file* с 3-мя строками.

![Пример вывода команды](/1-2/screenshots/task3_3.png)

***

## Task 5
Написать как можно больше различных вариантов команды cd, с помощью которых вы можете вернуться в домашнюю директорию вашего пользователя из директории */mnt*. Различные относительные пути также считаются разными вариантами.
```sh
$ cd               # 1 - возврат в домашнюю директорию
$ cd -             # 2 - возврат в директорию, из которой перешли в текущую
$ cd ~             # 3 - ~ заменяет путь к домашней директорию
$ cd ~/            # 4 
$ cd $HOME         # 5 - глобальная переменная HOME хранит путь к домашней директории текущего пользователя 
$ cd $HOME/        # 6 
$ cd /home/$USER   # 7 - глобальная переменная USER хранит имя текущего пользователя
$ cd /home/$USER/  # 8 
$ cd /home/admin   # 9 - абсолютный путь к домашней директории текущего пользователя
$ cd /home/admin/  # 10

```
![Пример вывода команды](/1-2/screenshots/task5_1.png)

***

## Task 6
Создайть одной командой в домашней директории 3 папки new, in-process, processed. При этом in-process должна содержать в себе еще 3 папки tread0, tread1, tread2.
```sh
$ mkdir new in-process{,/thread{0..2}} processed
```

![Пример вывода команды](/1-2/screenshots/task6_1.png)

Далее создать 100 файлов формата data[[:digit:]][[:digit:]] в папке new. 
```sh
$ touch ./new/data{0..9}{0..9}
```

![Пример вывода команды](/1-2/screenshots/task6_2.png)

Скопировать 34 файла в tread0 и по 33 в tread1 и tread2 соответственно. Вывести содержимое каталога in-process одной командой.
```sh
$ cp ./new/data{00..33} ./in-process/thread0/
$ cp ./new/data{34..66} ./in-process/thread1/
$ cp ./new/data{67..99} ./in-process/thread2/

$ ls ./in-process/thread{0..2}
```

![Пример вывода команды](/1-2/screenshots/task6_3.png)

После этого переместить все файлы из каталогов tread в processed одной командой. 
```sh
$ mv ./in-process/thread{0..2}/data[[:digit:]][[:digit:]] ./processed/
```

![Пример вывода команды](/1-2/screenshots/task6_4.png)

Вывести содержимое каталога in-process и processed опять же одной командой.
```sh
$ ls ./in-process/thread{0..2} ./processed
```

![Пример вывода команды](/1-2/screenshots/task6_5.png)

Сравнить количество файлов в каталогах new и processed при помощи изученных ранее команд, если они равны удалите файлы из new.
```sh
# [ 'str1' = 'str2' ] && < выполнится, если str1 == str2 > || < выполнится, если str1 != str2 > 

$ [ $(ls ./new | wc -l) = $(ls ./processed | wcw -l) ] && rm ./new/data[[:digit:]][[:digit:]] || echo "Numbers of files are not equal." 
```

![Пример вывода команды](/1-2/screenshots/task6_6.png)
